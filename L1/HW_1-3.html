<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        'use strict'
        /* Сложение имеет ассоциативность слева на право.
        Сначала выполнится сложение чисел, потом неявное приведение, потом конкатенация
        1. 10 + 10 = 20
        2. 20 + "10" = "20" + "10"
        3. "20" + "10" = "2010"
        */
        console.log(10 + 10 + "10"); 

        /* 
        Здесь ситуация следующая:
        Число + "Строка" = "Строка" + "Строка"
        10+"10" = "10"+"10" = "1010"
        Далее тоже самое, неявное приведение числа к строке с последующей конкатенацией
        "1010"+10 = "1010"+"10" = "101010"
        */
        console.log(10 + "10" + 10); 

        /*
        В данном случае унарный плюс перед строкой, превращает ее в число, 
        а далее происходит обычное сложение числовых значений.
        */
        console.log(10 + 10 + +"10");   // (обратите внимание на пробелы, пишите также) 
        
        /*
        Точного ответа не знаю, могу поразмышлять, зная ответ из console.log :)
        Первое. Унарный оператор преобразует не_числа в числа.
        Второе. Если бы выражении был унарный_плюс, то мы бы получили число 0
        (что логично: пустота в числовом выражении равна нулю),
        Из доп.материалов к данному уроку мы знаем, что выражение 10 / 0 = Infinity.
        Третье. Унарный минус делает то что и унарный плюс, но меняет знак.
        Таким образом, при приведении типов, мы получаем 10 / -0 = -Infiity.
        */       
        console.log(10 / -""); 

        /*
        Унарный плюс пытается привести строку к числу. Т.к. число записано неверно
        возвращает ошибку NaN(Это не число),
        10 / NaN = NaN //   10 / Не_число = Не_число 
        */
        console.log(10 / +"2,5"); // (да здесь запятая, это не опечатка)
    </script>
</body>
</html>